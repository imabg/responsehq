// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: subscriber.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscriber = `-- name: CreateSubscriber :one
INSERT INTO subscribers (id, type, value, is_verified, page_id) VALUES ($1,$2,$3,$4, $5) RETURNING id, type, value, is_verified, is_archived, page_id, created_at, updated_at
`

type CreateSubscriberParams struct {
	ID         string         `json:"id"`
	Type       SubscriberType `json:"type"`
	Value      string         `json:"value"`
	IsVerified pgtype.Bool    `json:"isVerified"`
	PageID     string         `json:"pageId"`
}

func (q *Queries) CreateSubscriber(ctx context.Context, arg CreateSubscriberParams) (Subscriber, error) {
	row := q.db.QueryRow(ctx, createSubscriber,
		arg.ID,
		arg.Type,
		arg.Value,
		arg.IsVerified,
		arg.PageID,
	)
	var i Subscriber
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Value,
		&i.IsVerified,
		&i.IsArchived,
		&i.PageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllSubscribersAgainstPage = `-- name: GetAllSubscribersAgainstPage :many
SELECT id, type, value, is_verified, is_archived, page_id, created_at, updated_at FROM subscribers WHERE page_id=$1
`

func (q *Queries) GetAllSubscribersAgainstPage(ctx context.Context, pageID string) ([]Subscriber, error) {
	rows, err := q.db.Query(ctx, getAllSubscribersAgainstPage, pageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscriber
	for rows.Next() {
		var i Subscriber
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Value,
			&i.IsVerified,
			&i.IsArchived,
			&i.PageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriberBasedOnType = `-- name: GetSubscriberBasedOnType :many
SELECT id, type, value, is_verified, is_archived, page_id, created_at, updated_at FROM subscribers WHERE type=$1 AND is_archived=$2
`

type GetSubscriberBasedOnTypeParams struct {
	Type       SubscriberType `json:"type"`
	IsArchived pgtype.Bool    `json:"isArchived"`
}

func (q *Queries) GetSubscriberBasedOnType(ctx context.Context, arg GetSubscriberBasedOnTypeParams) ([]Subscriber, error) {
	rows, err := q.db.Query(ctx, getSubscriberBasedOnType, arg.Type, arg.IsArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscriber
	for rows.Next() {
		var i Subscriber
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Value,
			&i.IsVerified,
			&i.IsArchived,
			&i.PageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriberById = `-- name: GetSubscriberById :one
SELECT id, type, value, is_verified, is_archived, page_id, created_at, updated_at FROM subscribers WHERE id = $1 AND is_archived = FALSE
`

func (q *Queries) GetSubscriberById(ctx context.Context, id string) (Subscriber, error) {
	row := q.db.QueryRow(ctx, getSubscriberById, id)
	var i Subscriber
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Value,
		&i.IsVerified,
		&i.IsArchived,
		&i.PageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriberById = `-- name: UpdateSubscriberById :exec
UPDATE subscribers SET is_archived=$1 WHERE id=$2
`

type UpdateSubscriberByIdParams struct {
	IsArchived pgtype.Bool `json:"isArchived"`
	ID         string      `json:"id"`
}

func (q *Queries) UpdateSubscriberById(ctx context.Context, arg UpdateSubscriberByIdParams) error {
	_, err := q.db.Exec(ctx, updateSubscriberById, arg.IsArchived, arg.ID)
	return err
}
